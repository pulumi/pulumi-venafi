// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package venafi

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type SshCertificate struct {
	pulumi.CustomResourceState

	// The SSH Certificate
	Certificate pulumi.StringOutput `pulumi:"certificate"`
	// Certificate type, server or client
	CertificateType pulumi.StringOutput `pulumi:"certificateType"`
	// The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used to authenticate to
	DestinationAddresses pulumi.StringArrayOutput `pulumi:"destinationAddresses"`
	// The requested certificate extensions.
	Extensions pulumi.StringArrayOutput `pulumi:"extensions"`
	// The DN of the policy folder where the certificate object will be created
	Folder pulumi.StringPtrOutput `pulumi:"folder"`
	// The requested force command.
	ForceCommand pulumi.StringPtrOutput `pulumi:"forceCommand"`
	// The identifier of the requested certificate
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// Passphrase for encrypting the private key
	KeyPassphrase pulumi.StringPtrOutput `pulumi:"keyPassphrase"`
	// The key size bits, they will be used for creating keypair
	KeySize pulumi.IntPtrOutput `pulumi:"keySize"`
	// The friendly name for the certificate object.
	ObjectName pulumi.StringPtrOutput `pulumi:"objectName"`
	// The requested principals.
	Principals pulumi.StringArrayOutput `pulumi:"principals"`
	// Private key
	PrivateKey pulumi.StringOutput `pulumi:"privateKey"`
	// Public key that will be used to generate the certificate
	PublicKey pulumi.StringPtrOutput `pulumi:"publicKey"`
	// Public key fingerprint SHA256
	PublicKeyFingerprint pulumi.StringOutput `pulumi:"publicKeyFingerprint"`
	// If the public key will be: file provided or local, service generated
	PublicKeyMethod pulumi.StringPtrOutput `pulumi:"publicKeyMethod"`
	// Serial number
	Serial pulumi.StringOutput `pulumi:"serial"`
	// CA fingerprint SHA256
	SigningCa pulumi.StringOutput `pulumi:"signingCa"`
	// The requested source addresses as list of IP/CIDR
	SourceAddresses pulumi.StringArrayOutput `pulumi:"sourceAddresses"`
	// The certificate issuing template
	Template pulumi.StringOutput `pulumi:"template"`
	// Valid from
	ValidFrom pulumi.StringOutput `pulumi:"validFrom"`
	// How much time the requester wants to have the certificate valid, the format is hours
	ValidHours pulumi.IntPtrOutput `pulumi:"validHours"`
	// Valid to
	ValidTo pulumi.StringOutput `pulumi:"validTo"`
	// If the line endings of service's private key will end on MS windows format
	Windows pulumi.BoolPtrOutput `pulumi:"windows"`
}

// NewSshCertificate registers a new resource with the given unique name, arguments, and options.
func NewSshCertificate(ctx *pulumi.Context,
	name string, args *SshCertificateArgs, opts ...pulumi.ResourceOption) (*SshCertificate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.KeyId == nil {
		return nil, errors.New("invalid value for required argument 'KeyId'")
	}
	if args.Template == nil {
		return nil, errors.New("invalid value for required argument 'Template'")
	}
	if args.KeyPassphrase != nil {
		args.KeyPassphrase = pulumi.ToSecret(args.KeyPassphrase).(pulumi.StringPtrOutput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"keyPassphrase",
	})
	opts = append(opts, secrets)
	var resource SshCertificate
	err := ctx.RegisterResource("venafi:index/sshCertificate:SshCertificate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSshCertificate gets an existing SshCertificate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSshCertificate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SshCertificateState, opts ...pulumi.ResourceOption) (*SshCertificate, error) {
	var resource SshCertificate
	err := ctx.ReadResource("venafi:index/sshCertificate:SshCertificate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SshCertificate resources.
type sshCertificateState struct {
	// The SSH Certificate
	Certificate *string `pulumi:"certificate"`
	// Certificate type, server or client
	CertificateType *string `pulumi:"certificateType"`
	// The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used to authenticate to
	DestinationAddresses []string `pulumi:"destinationAddresses"`
	// The requested certificate extensions.
	Extensions []string `pulumi:"extensions"`
	// The DN of the policy folder where the certificate object will be created
	Folder *string `pulumi:"folder"`
	// The requested force command.
	ForceCommand *string `pulumi:"forceCommand"`
	// The identifier of the requested certificate
	KeyId *string `pulumi:"keyId"`
	// Passphrase for encrypting the private key
	KeyPassphrase *string `pulumi:"keyPassphrase"`
	// The key size bits, they will be used for creating keypair
	KeySize *int `pulumi:"keySize"`
	// The friendly name for the certificate object.
	ObjectName *string `pulumi:"objectName"`
	// The requested principals.
	Principals []string `pulumi:"principals"`
	// Private key
	PrivateKey *string `pulumi:"privateKey"`
	// Public key that will be used to generate the certificate
	PublicKey *string `pulumi:"publicKey"`
	// Public key fingerprint SHA256
	PublicKeyFingerprint *string `pulumi:"publicKeyFingerprint"`
	// If the public key will be: file provided or local, service generated
	PublicKeyMethod *string `pulumi:"publicKeyMethod"`
	// Serial number
	Serial *string `pulumi:"serial"`
	// CA fingerprint SHA256
	SigningCa *string `pulumi:"signingCa"`
	// The requested source addresses as list of IP/CIDR
	SourceAddresses []string `pulumi:"sourceAddresses"`
	// The certificate issuing template
	Template *string `pulumi:"template"`
	// Valid from
	ValidFrom *string `pulumi:"validFrom"`
	// How much time the requester wants to have the certificate valid, the format is hours
	ValidHours *int `pulumi:"validHours"`
	// Valid to
	ValidTo *string `pulumi:"validTo"`
	// If the line endings of service's private key will end on MS windows format
	Windows *bool `pulumi:"windows"`
}

type SshCertificateState struct {
	// The SSH Certificate
	Certificate pulumi.StringPtrInput
	// Certificate type, server or client
	CertificateType pulumi.StringPtrInput
	// The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used to authenticate to
	DestinationAddresses pulumi.StringArrayInput
	// The requested certificate extensions.
	Extensions pulumi.StringArrayInput
	// The DN of the policy folder where the certificate object will be created
	Folder pulumi.StringPtrInput
	// The requested force command.
	ForceCommand pulumi.StringPtrInput
	// The identifier of the requested certificate
	KeyId pulumi.StringPtrInput
	// Passphrase for encrypting the private key
	KeyPassphrase pulumi.StringPtrInput
	// The key size bits, they will be used for creating keypair
	KeySize pulumi.IntPtrInput
	// The friendly name for the certificate object.
	ObjectName pulumi.StringPtrInput
	// The requested principals.
	Principals pulumi.StringArrayInput
	// Private key
	PrivateKey pulumi.StringPtrInput
	// Public key that will be used to generate the certificate
	PublicKey pulumi.StringPtrInput
	// Public key fingerprint SHA256
	PublicKeyFingerprint pulumi.StringPtrInput
	// If the public key will be: file provided or local, service generated
	PublicKeyMethod pulumi.StringPtrInput
	// Serial number
	Serial pulumi.StringPtrInput
	// CA fingerprint SHA256
	SigningCa pulumi.StringPtrInput
	// The requested source addresses as list of IP/CIDR
	SourceAddresses pulumi.StringArrayInput
	// The certificate issuing template
	Template pulumi.StringPtrInput
	// Valid from
	ValidFrom pulumi.StringPtrInput
	// How much time the requester wants to have the certificate valid, the format is hours
	ValidHours pulumi.IntPtrInput
	// Valid to
	ValidTo pulumi.StringPtrInput
	// If the line endings of service's private key will end on MS windows format
	Windows pulumi.BoolPtrInput
}

func (SshCertificateState) ElementType() reflect.Type {
	return reflect.TypeOf((*sshCertificateState)(nil)).Elem()
}

type sshCertificateArgs struct {
	// The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used to authenticate to
	DestinationAddresses []string `pulumi:"destinationAddresses"`
	// The requested certificate extensions.
	Extensions []string `pulumi:"extensions"`
	// The DN of the policy folder where the certificate object will be created
	Folder *string `pulumi:"folder"`
	// The requested force command.
	ForceCommand *string `pulumi:"forceCommand"`
	// The identifier of the requested certificate
	KeyId string `pulumi:"keyId"`
	// Passphrase for encrypting the private key
	KeyPassphrase *string `pulumi:"keyPassphrase"`
	// The key size bits, they will be used for creating keypair
	KeySize *int `pulumi:"keySize"`
	// The friendly name for the certificate object.
	ObjectName *string `pulumi:"objectName"`
	// The requested principals.
	Principals []string `pulumi:"principals"`
	// Public key that will be used to generate the certificate
	PublicKey *string `pulumi:"publicKey"`
	// If the public key will be: file provided or local, service generated
	PublicKeyMethod *string `pulumi:"publicKeyMethod"`
	// The requested source addresses as list of IP/CIDR
	SourceAddresses []string `pulumi:"sourceAddresses"`
	// The certificate issuing template
	Template string `pulumi:"template"`
	// How much time the requester wants to have the certificate valid, the format is hours
	ValidHours *int `pulumi:"validHours"`
	// If the line endings of service's private key will end on MS windows format
	Windows *bool `pulumi:"windows"`
}

// The set of arguments for constructing a SshCertificate resource.
type SshCertificateArgs struct {
	// The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used to authenticate to
	DestinationAddresses pulumi.StringArrayInput
	// The requested certificate extensions.
	Extensions pulumi.StringArrayInput
	// The DN of the policy folder where the certificate object will be created
	Folder pulumi.StringPtrInput
	// The requested force command.
	ForceCommand pulumi.StringPtrInput
	// The identifier of the requested certificate
	KeyId pulumi.StringInput
	// Passphrase for encrypting the private key
	KeyPassphrase pulumi.StringPtrInput
	// The key size bits, they will be used for creating keypair
	KeySize pulumi.IntPtrInput
	// The friendly name for the certificate object.
	ObjectName pulumi.StringPtrInput
	// The requested principals.
	Principals pulumi.StringArrayInput
	// Public key that will be used to generate the certificate
	PublicKey pulumi.StringPtrInput
	// If the public key will be: file provided or local, service generated
	PublicKeyMethod pulumi.StringPtrInput
	// The requested source addresses as list of IP/CIDR
	SourceAddresses pulumi.StringArrayInput
	// The certificate issuing template
	Template pulumi.StringInput
	// How much time the requester wants to have the certificate valid, the format is hours
	ValidHours pulumi.IntPtrInput
	// If the line endings of service's private key will end on MS windows format
	Windows pulumi.BoolPtrInput
}

func (SshCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sshCertificateArgs)(nil)).Elem()
}

type SshCertificateInput interface {
	pulumi.Input

	ToSshCertificateOutput() SshCertificateOutput
	ToSshCertificateOutputWithContext(ctx context.Context) SshCertificateOutput
}

func (*SshCertificate) ElementType() reflect.Type {
	return reflect.TypeOf((**SshCertificate)(nil)).Elem()
}

func (i *SshCertificate) ToSshCertificateOutput() SshCertificateOutput {
	return i.ToSshCertificateOutputWithContext(context.Background())
}

func (i *SshCertificate) ToSshCertificateOutputWithContext(ctx context.Context) SshCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshCertificateOutput)
}

// SshCertificateArrayInput is an input type that accepts SshCertificateArray and SshCertificateArrayOutput values.
// You can construct a concrete instance of `SshCertificateArrayInput` via:
//
//	SshCertificateArray{ SshCertificateArgs{...} }
type SshCertificateArrayInput interface {
	pulumi.Input

	ToSshCertificateArrayOutput() SshCertificateArrayOutput
	ToSshCertificateArrayOutputWithContext(context.Context) SshCertificateArrayOutput
}

type SshCertificateArray []SshCertificateInput

func (SshCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SshCertificate)(nil)).Elem()
}

func (i SshCertificateArray) ToSshCertificateArrayOutput() SshCertificateArrayOutput {
	return i.ToSshCertificateArrayOutputWithContext(context.Background())
}

func (i SshCertificateArray) ToSshCertificateArrayOutputWithContext(ctx context.Context) SshCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshCertificateArrayOutput)
}

// SshCertificateMapInput is an input type that accepts SshCertificateMap and SshCertificateMapOutput values.
// You can construct a concrete instance of `SshCertificateMapInput` via:
//
//	SshCertificateMap{ "key": SshCertificateArgs{...} }
type SshCertificateMapInput interface {
	pulumi.Input

	ToSshCertificateMapOutput() SshCertificateMapOutput
	ToSshCertificateMapOutputWithContext(context.Context) SshCertificateMapOutput
}

type SshCertificateMap map[string]SshCertificateInput

func (SshCertificateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SshCertificate)(nil)).Elem()
}

func (i SshCertificateMap) ToSshCertificateMapOutput() SshCertificateMapOutput {
	return i.ToSshCertificateMapOutputWithContext(context.Background())
}

func (i SshCertificateMap) ToSshCertificateMapOutputWithContext(ctx context.Context) SshCertificateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SshCertificateMapOutput)
}

type SshCertificateOutput struct{ *pulumi.OutputState }

func (SshCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SshCertificate)(nil)).Elem()
}

func (o SshCertificateOutput) ToSshCertificateOutput() SshCertificateOutput {
	return o
}

func (o SshCertificateOutput) ToSshCertificateOutputWithContext(ctx context.Context) SshCertificateOutput {
	return o
}

// The SSH Certificate
func (o SshCertificateOutput) Certificate() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.Certificate }).(pulumi.StringOutput)
}

// Certificate type, server or client
func (o SshCertificateOutput) CertificateType() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.CertificateType }).(pulumi.StringOutput)
}

// The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used to authenticate to
func (o SshCertificateOutput) DestinationAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringArrayOutput { return v.DestinationAddresses }).(pulumi.StringArrayOutput)
}

// The requested certificate extensions.
func (o SshCertificateOutput) Extensions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringArrayOutput { return v.Extensions }).(pulumi.StringArrayOutput)
}

// The DN of the policy folder where the certificate object will be created
func (o SshCertificateOutput) Folder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringPtrOutput { return v.Folder }).(pulumi.StringPtrOutput)
}

// The requested force command.
func (o SshCertificateOutput) ForceCommand() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringPtrOutput { return v.ForceCommand }).(pulumi.StringPtrOutput)
}

// The identifier of the requested certificate
func (o SshCertificateOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// Passphrase for encrypting the private key
func (o SshCertificateOutput) KeyPassphrase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringPtrOutput { return v.KeyPassphrase }).(pulumi.StringPtrOutput)
}

// The key size bits, they will be used for creating keypair
func (o SshCertificateOutput) KeySize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.IntPtrOutput { return v.KeySize }).(pulumi.IntPtrOutput)
}

// The friendly name for the certificate object.
func (o SshCertificateOutput) ObjectName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringPtrOutput { return v.ObjectName }).(pulumi.StringPtrOutput)
}

// The requested principals.
func (o SshCertificateOutput) Principals() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringArrayOutput { return v.Principals }).(pulumi.StringArrayOutput)
}

// Private key
func (o SshCertificateOutput) PrivateKey() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.PrivateKey }).(pulumi.StringOutput)
}

// Public key that will be used to generate the certificate
func (o SshCertificateOutput) PublicKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringPtrOutput { return v.PublicKey }).(pulumi.StringPtrOutput)
}

// Public key fingerprint SHA256
func (o SshCertificateOutput) PublicKeyFingerprint() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.PublicKeyFingerprint }).(pulumi.StringOutput)
}

// If the public key will be: file provided or local, service generated
func (o SshCertificateOutput) PublicKeyMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringPtrOutput { return v.PublicKeyMethod }).(pulumi.StringPtrOutput)
}

// Serial number
func (o SshCertificateOutput) Serial() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.Serial }).(pulumi.StringOutput)
}

// CA fingerprint SHA256
func (o SshCertificateOutput) SigningCa() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.SigningCa }).(pulumi.StringOutput)
}

// The requested source addresses as list of IP/CIDR
func (o SshCertificateOutput) SourceAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringArrayOutput { return v.SourceAddresses }).(pulumi.StringArrayOutput)
}

// The certificate issuing template
func (o SshCertificateOutput) Template() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.Template }).(pulumi.StringOutput)
}

// Valid from
func (o SshCertificateOutput) ValidFrom() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.ValidFrom }).(pulumi.StringOutput)
}

// How much time the requester wants to have the certificate valid, the format is hours
func (o SshCertificateOutput) ValidHours() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.IntPtrOutput { return v.ValidHours }).(pulumi.IntPtrOutput)
}

// Valid to
func (o SshCertificateOutput) ValidTo() pulumi.StringOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.StringOutput { return v.ValidTo }).(pulumi.StringOutput)
}

// If the line endings of service's private key will end on MS windows format
func (o SshCertificateOutput) Windows() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SshCertificate) pulumi.BoolPtrOutput { return v.Windows }).(pulumi.BoolPtrOutput)
}

type SshCertificateArrayOutput struct{ *pulumi.OutputState }

func (SshCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SshCertificate)(nil)).Elem()
}

func (o SshCertificateArrayOutput) ToSshCertificateArrayOutput() SshCertificateArrayOutput {
	return o
}

func (o SshCertificateArrayOutput) ToSshCertificateArrayOutputWithContext(ctx context.Context) SshCertificateArrayOutput {
	return o
}

func (o SshCertificateArrayOutput) Index(i pulumi.IntInput) SshCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SshCertificate {
		return vs[0].([]*SshCertificate)[vs[1].(int)]
	}).(SshCertificateOutput)
}

type SshCertificateMapOutput struct{ *pulumi.OutputState }

func (SshCertificateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SshCertificate)(nil)).Elem()
}

func (o SshCertificateMapOutput) ToSshCertificateMapOutput() SshCertificateMapOutput {
	return o
}

func (o SshCertificateMapOutput) ToSshCertificateMapOutputWithContext(ctx context.Context) SshCertificateMapOutput {
	return o
}

func (o SshCertificateMapOutput) MapIndex(k pulumi.StringInput) SshCertificateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SshCertificate {
		return vs[0].(map[string]*SshCertificate)[vs[1].(string)]
	}).(SshCertificateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SshCertificateInput)(nil)).Elem(), &SshCertificate{})
	pulumi.RegisterInputType(reflect.TypeOf((*SshCertificateArrayInput)(nil)).Elem(), SshCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SshCertificateMapInput)(nil)).Elem(), SshCertificateMap{})
	pulumi.RegisterOutputType(SshCertificateOutput{})
	pulumi.RegisterOutputType(SshCertificateArrayOutput{})
	pulumi.RegisterOutputType(SshCertificateMapOutput{})
}
